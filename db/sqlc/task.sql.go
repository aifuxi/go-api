// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: task.sql

package sqlc

import (
	"context"
)

const createTask = `-- name: CreateTask :one
INSERT INTO "tasks"
(content, is_done)
VALUES ($1, $2)RETURNING id, content, is_done, created_at, done_at
`

type CreateTaskParams struct {
	Content string `db:"content" json:"content"`
	IsDone  int64  `db:"is_done" json:"isDone"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.queryRow(ctx, q.createTaskStmt, createTask, arg.Content, arg.IsDone)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.IsDone,
		&i.CreatedAt,
		&i.DoneAt,
	)
	return i, err
}

const listTasks = `-- name: ListTasks :many
SELECT id, content, is_done, created_at, done_at FROM "tasks"
ORDER BY id LIMIT $1 OFFSET $2
`

type ListTasksParams struct {
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

func (q *Queries) ListTasks(ctx context.Context, arg ListTasksParams) ([]Task, error) {
	rows, err := q.query(ctx, q.listTasksStmt, listTasks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsDone,
			&i.CreatedAt,
			&i.DoneAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
